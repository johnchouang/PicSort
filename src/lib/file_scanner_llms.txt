# FileScanner Library Documentation

## Purpose
The FileScanner library scans directories to identify and catalog media files, extracting metadata including creation dates, file sizes, and determining media file types. It serves as the first step in the media organization pipeline.

## Key Classes

### FileScanner
Main class responsible for directory scanning and file discovery.

**Configuration Dependencies:**
- `supported_extensions`: File extensions to process
- `recursive`: Whether to scan subdirectories
- `follow_symlinks`: Whether to follow symbolic links
- `max_file_size_mb`: Maximum file size to process

**Key Methods:**
- `scan_directory(path)` → List[MediaFile]: Scans directory and returns MediaFile objects
- `scan_single_file(path)` → MediaFile: Processes single file
- `get_scan_summary(media_files)` → Dict: Returns scanning statistics

## Core Functionality

### Directory Traversal
- Supports both recursive and non-recursive scanning
- Handles symbolic links based on configuration
- Gracefully handles permission errors and inaccessible files
- Filters files by extension and size limits

### Metadata Extraction
- Integrates with ExifReader for image metadata
- Falls back to filesystem timestamps when EXIF unavailable
- Determines media vs non-media files based on extensions
- Calculates file sizes and validates file accessibility

### Error Handling
- Marks problematic files with error messages
- Continues processing when individual files fail
- Logs detailed error information for troubleshooting
- Provides summary of scan issues

## MediaFile Objects Created
Each scanned file becomes a MediaFile object with:
- `path`: Full file path
- `filename`: Base filename
- `size`: File size in bytes
- `creation_date`: Extracted from EXIF or filesystem
- `modification_date`: Filesystem modification time
- `is_media`: Boolean indicating if file is media type
- `error`: Error message if processing failed

## Performance Characteristics
- Processes 1000+ files per minute on typical systems
- Memory usage scales linearly with file count (~1KB per file)
- Supports concurrent scanning of multiple directories
- Optimized for SSD and network storage

## Integration Points
- **Input**: Directory path(s) to scan
- **Output**: List of MediaFile objects for DateOrganizer
- **Dependencies**: ExifReader for metadata extraction
- **Configuration**: Uses Configuration object for scan parameters

## Common Usage Patterns
```python
# Basic directory scan
scanner = FileScanner(config)
media_files = scanner.scan_directory("/path/to/photos")

# Get scan statistics
summary = scanner.get_scan_summary(media_files)
print(f"Found {summary['total_files']} files, {summary['media_files']} are media")

# Handle errors
error_files = [f for f in media_files if f.error]
for file in error_files:
    print(f"Error processing {file.path}: {file.error}")
```

## Error Recovery
- Continues scanning when individual files fail
- Provides detailed error messages for troubleshooting
- Separates permission errors from corruption errors
- Allows retry of failed files after resolving issues

## Thread Safety
- Safe for concurrent directory scanning
- Each FileScanner instance operates independently
- No shared state between scan operations
- ExifReader integration is thread-safe