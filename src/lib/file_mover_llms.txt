# FileMover Library Documentation

## Purpose
The FileMover library safely executes file move operations with verification, duplicate handling, and rollback capabilities. It serves as the final execution phase of the media organization pipeline, actually moving files to their target locations.

## Key Classes

### FileMover
Main class responsible for safely moving files with verification and error handling.

**Configuration Dependencies:**
- `verify_checksum`: Whether to verify file integrity with MD5 checksums
- `duplicate_handling`: How to handle filename conflicts ('increment', 'skip', 'overwrite')
- Safety and verification settings

**Key Methods:**
- `move_files(organization, dry_run=False)` → List[FileOperation]: Executes all moves in organization
- `move_file(operation, dry_run=False)` → FileOperation: Moves single file
- `verify_operation(operation)` → bool: Verifies move completed successfully
- `get_operation_summary(operations)` → Dict: Summarizes move results

## Core Functionality

### Safe File Moving
- Copy-then-delete approach for maximum safety
- Optional MD5 checksum verification
- Automatic cleanup of partial copies on failure
- Preserves file timestamps and permissions

### Duplicate Handling
Three strategies for filename conflicts:
- **increment**: Adds numbers (file_1.jpg, file_2.jpg)
- **skip**: Leaves existing file unchanged
- **overwrite**: Replaces existing file

### Directory Management
- Creates target directories automatically
- Handles nested directory structures
- Manages permissions for new directories
- Validates directory accessibility

### Operation Tracking
Each move creates a FileOperation object tracking:
- Source and destination paths
- Operation status and timing
- Error messages and recovery information
- Checksum verification results

## File Operation States
FileOperation objects progress through states:
- `pending`: Operation created but not started
- `copying`: File being copied to destination
- `verifying`: Checksum verification in progress
- `completed`: Operation finished successfully
- `failed`: Operation failed with error
- `skipped`: Operation skipped (dry run or duplicate skip)

## Duplicate Resolution Logic
```python
# For filename conflicts:
original.jpg       → original.jpg (if not exists)
original.jpg       → original_1.jpg (if original.jpg exists)
original_1.jpg     → original_2.jpg (if original_1.jpg also exists)
```

Handles complex filenames:
- `IMG_20231225_143000.DSC_1234.jpg` → `IMG_20231225_143000.DSC_1234_1.jpg`
- `file.with.dots.txt` → `file.with.dots_1.txt`
- `README` (no extension) → `README_1`

## Checksum Verification
When enabled:
1. Calculate MD5 of source file before copy
2. Copy file to destination
3. Calculate MD5 of destination file
4. Compare checksums - fail if different
5. Remove source file only after verification

## Performance Characteristics
- Actual moves: 200+ files per minute (depends on file size and storage)
- Dry run planning: 10,000+ files per minute
- Memory usage: ~2KB per operation
- Scales with storage speed, not CPU

## Integration Points
- **Input**: Organization dictionary from DateOrganizer
- **Output**: List of FileOperation objects with results
- **Dependencies**: Configuration for safety and duplicate settings
- **Side Effects**: Actual file system modifications

## Common Usage Patterns
```python
# Basic file moving
mover = FileMover(config)
operations = mover.move_files(organization, dry_run=False)

# Dry run preview
operations = mover.move_files(organization, dry_run=True)
print(f"Would move {len(operations)} files")

# Check results
summary = mover.get_operation_summary(operations)
print(f"Completed: {summary['completed']}, Failed: {summary['failed']}")

# Handle failures
for op in operations:
    if op.status == 'failed':
        print(f"Failed to move {op.source_file.path}: {op.error_message}")

# Verify operations
for op in operations:
    if op.status == 'completed':
        if not mover.verify_operation(op):
            print(f"Verification failed for {op.destination_path}")
```

## Error Handling and Recovery
- Detailed error messages for each failure type
- Automatic cleanup of partial copies
- Preservation of original files on failure
- Clear distinction between recoverable and permanent errors

### Common Error Types
- **Permission denied**: Insufficient rights to source or destination
- **Disk full**: No space available on target drive
- **Checksum mismatch**: File corruption during copy
- **File locked**: Source file in use by another process
- **Path too long**: Destination path exceeds filesystem limits

## Safety Features
- Never removes source file until copy is verified
- Creates backup of checksums for verification
- Handles interrupted operations gracefully
- Provides rollback information for undo operations

## Dry Run Mode
- Simulates all operations without file modifications
- Validates paths and permissions
- Identifies potential conflicts and issues
- Provides accurate operation planning

## Thread Safety
- Individual move operations are thread-safe
- Concurrent moves to different directories supported
- Shared FileMover instance safe for multiple threads
- File system operations use atomic patterns where possible

## Operation Logging Integration
- Each FileOperation can be logged for audit trail
- Supports undo operations through operation logs
- Provides timing and performance metrics
- Enables resumption of interrupted batch operations