# ConfigManager Library Documentation

## Purpose
The ConfigManager library handles loading, saving, validation, and migration of user configuration settings. It provides centralized configuration management with support for default values, validation, and interactive setup workflows.

## Key Classes

### ConfigManager
Main class responsible for configuration file management and validation.

**Key Methods:**
- `load_config(config_path=None)` → Configuration: Loads configuration from file or creates default
- `save_config(config, config_path=None)`: Saves configuration to file
- `create_default_config()` → Configuration: Creates configuration with default values
- `validate_config(config)` → List[str]: Validates configuration and returns errors
- `interactive_setup()` → Configuration: Guides user through configuration setup

## Configuration File Format
Uses YAML format for human readability:
```yaml
# PicSort Configuration
date_format: "MM.YYYY"
duplicate_handling: "increment"
verify_checksum: true
process_all_files: false
supported_extensions:
  images: [".jpg", ".jpeg", ".png", ".gif", ".bmp", ".tiff", ".tif", ".webp"]
  videos: [".mp4", ".avi", ".mov", ".mkv", ".wmv", ".flv", ".m4v"]
max_file_size_mb: 1000
recursive: true
follow_symlinks: false
dry_run_default: true
```

## Configuration Location
Default configuration paths by platform:
- **Windows**: `%APPDATA%\PicSort\config.yaml`
- **macOS**: `~/Library/Application Support/PicSort/config.yaml`
- **Linux**: `~/.config/PicSort/config.yaml`

Alternative locations:
- Current directory: `./picsort-config.yaml`
- User-specified path via CLI argument

## Configuration Parameters

### Core Settings
- `date_format`: Folder naming pattern (MM.YYYY, YYYY-MM, etc.)
- `duplicate_handling`: Conflict resolution (increment/skip/overwrite)
- `verify_checksum`: Enable MD5 verification during moves
- `process_all_files`: Include non-media files in organization

### File Processing
- `supported_extensions`: Dictionary of file types to process
- `max_file_size_mb`: Maximum file size limit
- `recursive`: Scan subdirectories recursively
- `follow_symlinks`: Follow symbolic links during scanning

### User Experience
- `dry_run_default`: Default to dry run mode for safety
- `progress_bars`: Show progress indicators
- `verbose_logging`: Enable detailed log output
- `confirm_destructive`: Require confirmation for destructive operations

## Validation Rules
Configuration validation checks:
- Date format contains valid placeholders
- Duplicate handling is valid option
- File size limits are reasonable
- File extensions are properly formatted
- Paths are accessible and writable

## Interactive Setup Mode
Guides users through configuration with prompts:
1. Welcome and explanation
2. Date format selection with examples
3. File type preferences
4. Safety settings (checksums, dry run)
5. Advanced options (recursive scanning, size limits)
6. Configuration summary and confirmation

## Migration Support
Handles configuration version updates:
- Detects old configuration formats
- Migrates settings to new format
- Preserves user customizations
- Provides migration summaries

## Default Configuration Values
```python
DEFAULT_CONFIG = {
    'date_format': 'MM.YYYY',
    'duplicate_handling': 'increment',
    'verify_checksum': True,
    'process_all_files': False,
    'max_file_size_mb': 1000,
    'recursive': True,
    'follow_symlinks': False,
    'dry_run_default': True,
    'supported_extensions': {
        'images': ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.tif', '.webp'],
        'videos': ['.mp4', '.avi', '.mov', '.mkv', '.wmv', '.flv', '.m4v']
    }
}
```

## Configuration Object
The Configuration class provides:
- Type-safe access to settings
- Automatic validation on property changes
- Method to get combined supported extensions
- JSON serialization support for API integration

## Common Usage Patterns
```python
# Load existing or create default configuration
config_manager = ConfigManager()
config = config_manager.load_config()

# Interactive setup for new users
if not config_manager.config_exists():
    config = config_manager.interactive_setup()

# Validate configuration
errors = config_manager.validate_config(config)
if errors:
    print("Configuration errors:", errors)

# Save modified configuration
config.date_format = "YYYY-MM"
config_manager.save_config(config)

# Create configuration for specific use case
config = config_manager.create_default_config()
config.process_all_files = True
config.verify_checksum = False  # For performance
```

## Error Handling
- Graceful handling of missing configuration files
- Clear error messages for invalid settings
- Automatic fallback to defaults on corruption
- User-friendly validation error descriptions

## Environment Integration
- Supports environment variable overrides
- Command-line argument integration
- Profile-specific configurations
- Portable configuration files

## Platform Considerations
- Cross-platform path handling
- Platform-specific default settings
- File permission handling
- Unicode filename support

## Performance Characteristics
- Configuration loading: Sub-millisecond for typical files
- Validation: Processes complex configurations instantly
- File I/O: Minimal overhead for save/load operations
- Memory usage: <1KB per configuration object

## Thread Safety
- Configuration objects are immutable after creation
- ConfigManager operations are thread-safe
- File access uses appropriate locking
- No shared mutable state between operations

## Integration Points
- **CLI**: Provides configuration for all commands
- **Libraries**: All processing libraries depend on Configuration
- **Interactive Mode**: Powers setup wizard and config commands
- **Logging**: Integrates with logging configuration settings